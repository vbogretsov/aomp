\section{Введение}

\subsection{Разделяемые объекты и синхронизация}
\label{1-1}

Рассмотрим проблему разделяемых между потоками объектов на примере следующей
задачи: найти количество простых чисел в диапазоне от $1$ до $10^{10}$ на
компьютере, который может обрабатывать $10$ параллельных потоков.

Первым решением может быть разделение всего интервала на $10$ равных по
количеству чисел промежутков, каждый из которых обрабатывается в отдельном
потоке. Однако тут сразу возникает проблема. Большие числа сложнее проверять на
простоту, чем меньшие, следовательно, нагрузка между потоками распределяется
неравномерно, что приводит к неэффективному использованию потоков.

Более равномерное использование потоков даёт следующее решение. Каждому потоку в
начале работы назначается одно число. Он проверяет его на простоту. Когда
проверка окончена, он переходит к следующему числу, которое ещё не было
обработано ни одним потоком. В данном случае имеет место разделение данных между
потоками: каждый поток должен знать, какие числа были обработаны, а какие нет.
Более того, каждый поток должен получать уникальное число для проверки на
простоту.

Предположим, переменная \textit{counter} содержит последнее число, взятое на
проверку каким-либо потоком. Тогда, по завершении проверки на простоту, поток
должен увеличить данную переменную на 1 и повторить проверку на простоту для
нового значения. Для этого он должен выполнить следующие операции:

\begin{enumerate}
    \item Прочитать значение переменной \textit{counter} во временную
    переменную \textit{tmp}.
    \item Записать в переменную \textit{counter} новое значение
    \textit{tmp + 1}.
\end{enumerate}

Теперь предположим следующую ситуацию: потоки \textit{A} и \textit{B} хотят
получить новое число для проверки на простоту. Для этого каждый из них должен
выполнить шаги 1-2. Пусть текущее значение переменной \textit{counter} равно 11,
поток \textit{A} выполняет шаг 1. Значение его локальной переменной \textit{tmp}
в этот момент равно 11. В этот момент поток \textit{B} также выполняет шаг 1.
Значение его локальной переменной \textit{tmp} также будет 11. Далее поток
\textit{B} вычисляет \textit{tmp + 1} и записывает результат в \textit{counter}.
Поток \textit{A} делает тоже самое. В результате оба потока выполняют проверку
на простоту для числа 12, а переменная \textit{counter} содержит значение 12,
хотя должна содержать значение 13.

Причина полученного неправильного состояния программы заключается в том, что
шаги 1-2 каждый поток должен выполнять \say{одновременно}. То есть поток
\textit{B} не может прочитать из переменной \textit{counter} значение 11 если
поток \textit{A} уже прочитал его.

В современных системах есть специальные инструкции, которые позволяют для
некоторой переменной одновременно выполнить последовательность действий
прочитать-изменить-записать. Такое изменение переменной называется
\textit{атомарным}, а сами такие инструкции называются \textit{атомарными}.

Также рассмотренная проблема может быть решена использованием
\textit{критической секции} для обновления переменной \textit{counter}. Оба
подхода будут рассмотрены далее.

\subsection{Взаимное исключение}
\label{1-2}

Рассмотрим следующую задачу. Алиса и Боб живут по соседству и у них общий двор.
У Боба есть собака, а у Алисы кошка. Животные друг с другом не ладят, но хотят
гулять во дворе. Необходимо разработать алгоритм, который позволяет выпускать
животных во двор так, чтобы они друг с другом не встретились.

Следует отметить, что ни звонок соседу ни визит к нему с целью выяснить, не
гуляет ли его питомец во дворе, не являются решениями данной задачи, так как
сосед может не услышать телефон или звонок в дверь по различным причинам.

Приведённый ниже алгоритм решает данную задачу.

Если Алиса хочет отправить своего кота во двор, она выполняет следующие шаги:

\begin{enumerate}
    \item Поднимает флаг над своим домом.
    \item Если флаг над домом Боба поднят, она опускает свой флаг.
    \item Если флаг над домом Боба опущен, она выпускает кота, когда кот придёт
    домой, она опускает флаг.
\end{enumerate}

Если Боб хочет отправить свою собаку во двор, он выполняет следующие шаги:

\begin{enumerate}
    \item Поднимает флаг над своим домом.
    \item Если флаг Алисы поднят, Боб опускает свой флаг, ждёт пока Алиса
    опустит свой флаг и затем поднимает свой флаг.
    \item Когда флаг Боба поднят, а флаг Алисы опущен, Боб выпускает свою собаку
    во двор.
    \item Когда собака возвращается, Боб опускает свой флаг.
\end{enumerate}

Докажем, что данный алгоритм предотвращает одновременное появление во дворе и
кота и собаки. Предположим, что это не так и животные одновременно появились во
дворе. Так как кот появился во дворе, то Алиса до этого подняла свой флаг и не
увидела флаг Боба. Но так как и собака появилась во дворе, Боб должен был
поднять свой флаг. Раз Алиса его не увидела, он поднял его после того, как
она подняла свой флаг. Поэтому собака могла появиться во дворе только, если Боб
нарушил алгоритм, чего быть не должно. Следовательно, животные не могут
появиться во дворе одновременно.

Мы доказали, что приведённый алгоритм обладает свойством взаимного исключения
(\textit{mutual exclusion}). Однако, зачастую это не единственное свойство,
которым должен обладать параллельный алгоритм. Рассмотрим эти свойства.

\textit{Отсутствие взаимных блокировок (deadlock-freedom)}. Данное свойство
означает, что, если два и более потока одновременно хотят получить доступ к
общему ресурсу, то как минимум одному из них это удастся. В нашем примере это
означает, что как минимум одно животное попадёт во двор.

Докажем, что алгоритм, регулирующий доступ животных во двор обладает этим
свойством. Предположим, что Алиса и Боб хотят выпустить во двор своих питомцев.
Для этого каждый из них должен поднять свой флаг. Согласно алгоритму, если Боб
видит флаг Алисы, он должен опустить свой и уступить ей. Тогда Алиса увидит, что
флаг Боба опущен и выпустит кота во двор.

\textit{Отсутствие голодания (starvation-freedom)}. Данное свойство означает,
что, если два и более потока хотят получить доступ к общему ресурсу, то будет
отсутствовать ситуация, при которой один из потоков пользуется ресурсом
неограниченное время, в то время как остальные ждут. В нашем примере при
одновременном желании выпустить животных во двор, Боб будет всё время уступать
Алисе. Следовательно, данный алгоритм не облает этим свойством.

\textit{Ожидание (waiting)}. Данное свойство означает, что поток, получивший
доступ к общему ресурсу, должен отпустить его при невозможности использования.
В нашем примере рассмотрим следующую ситуацию. Алиса подняла флаг и внезапно
заболела так, что её увезла скорая. В таком случае она не будет пользоваться
двором, но им и не сможет воспользоваться Боб, так как он должен отложить свою
попытку, если видит поднятый флаг Алисы. Очевидно, рассматриваемый алгоритм не
обладает этим свойством.

В многопоточных системах происходят 2 основных типа коммуникаций:

\begin{itemize}
    \item \textit{Мгновенная} требует одновременного участия сторон.
    \item \textit{Постоянная} позволяет отправителю и получателю
    взаимодействовать в различные промежутки времени.
\end{itemize}

Взаимное исключение требует постоянной коммуникации. В современных операционных
системах одним из основных способов взаимодействия между потоками является
\textit{прерывание}. Если поток \textit{A} хочет послать сообщение потоку
\textit{B}, он устанавливает определённый бит, который периодически проверяется
потоком \textit{B}. Когда поток \textit{B} обнаруживает, что данный бит
изменился, он выполняет необходимое действие и сбрасывает этот бит. При этом
данный бит не может быть сброшен потоком \textit{A}.

В данном разделе мы увидели, что проблема взаимного исключения потоков при
доступе к общему ресурсу может быть решена двумя битами (флагами в
рассмотренном примере).

\subsection{Проблема поставщика-потребителя}
\label{1-3}

Рассмотрим следующую задачу. У Алисы есть кот и собака, они атакуют Боба каждый
раз, как только увидят его, но при этом Боб должен кормить их. Боб должен
принести еду во двор, когда там нет животных, а Алиса не выпускает их во двор до
тех пор, пока там нет еды. Эта задача известна как задача
\textit{поставщика-потребителя}.

Алисе и Бобу необходимо действовать следующим образом. Боб ставит банку возле
окна Алисы, привязывает её верёвкой и другой конец протягивает до своего дома.

Алиса действует следующим образом:

\begin{enumerate}
    \item Ждёт пока банка не упадёт.
    \item Когда банка упала, выпускает животных.
    \item Когда еда во дворе закончилась, забирает животных и поднимает банку.
\end{enumerate}

Боб действует следующим образом:
\begin{enumerate}
    \item Ждёт, пока банка не будет поднята.
    \item Когда банка поднята, выходит во двор и оставляет еду.
    \item Покидает двор, дёргает за верёвку, чтобы уронить банку.
\end{enumerate}

Рассмотрим, какими свойствами обладает данный алгоритм.

\textbf{Взаимное исключение}. Банка может находиться в одном из двух состояний:
либо стоит либо лежит. Предположим, она лежит. В таком случае Боб не находится
во дворе, а животные могут находиться. Как только они ушли со двора, Алиса
поднимает банку и животные не могут туда попасть пока банка не будет опущена
Бобом. При этом Боб может находиться во дворе. Когда он положит корм и покинет
двор, он уронит банку. Это будет означать, что он не может попасть во двор, до
тех пор, пока Алиса не поднимет банку.

\textbf{Отсутствие голодания}. Предположим что Боб не может попасть во двор.
Это означает, что животные находятся во дворе и банка опущена. Но спустя
некоторое время еда пропадает, Алиса, согласно алгоритму, должна забрать
животных со двора и поднять банку. В этот момент Боб сможет попасть во двор.

\textbf{Поставщик-потребитель}. Следует из взаимного исключения.

\subsection{Проблема читателей-писателей}

Рассмотрим следующую проблему. Алиса и Боб хотят иметь возможность обмениваться
сообщениями. Для этого Боб ставит большую доску на против окна Алисы. Доска
содержит большие клетки. Боб пишет по одному слову в одну клетку, а Алиса читает
сообщение последовательно по клетке за раз (например при помощи бинокля).
Предположим следующую ситуацию. 

Боб пишет:

\textit{я продал кота}

Алиса прочитала два слова:

\textit{я продал}

В этот момент Боб стирает два последних слова и пишет:

\textit{я помыл собаку}

Алиса читает следующее слово, и для неё всё сообщение принимает вид:

\textit{я продал собаку}

Как видим, это совсем не то, что изначально планировал написать Боб. Для решения
данной задачи можно было бы воспользоваться алгоритмом \textit{взаимное
исключение} или \textit{поставщик-потребитель}. Однако, оба варианта содержат
недостаток в виде проблемы \textit{ожидания}. В контексте разделяемой между
потоками памяти проблема \textit{читателей-писателей} означает возможность для
потока прочитать мгновенное состояние нескольких участков памяти без ожидания
и без того, чтобы другие потоки, желающие произвести чтение или запись общей
памяти, ожидали, пока данный завершит чтение. Такое решение существует и будет
описано в дальнейшем.

\subsection{Закон Амдала}

В идеальном случае увеличение числа процессоров с одного до $n$ должно увеличить
производительность в $n$ раз. Однако, на практике такого никогда не случается.
Связано это с тем, что при распараллеливании появляются накладные расходы на
взаимодействие между потоками.

Рассмотрим пример, когда 5 рабочих должны покрасить стены в 5 комнатах. Если
комнаты одинакового размера, то при одинаковой скорости каждого рабочего мы
получим 5-кратное увеличение производительности относительно случая, когда все
комнаты раскрашивал бы один рабочий. Но, если, одна из комнат в 2 раза больше
остальных, то, при таком же подходе, время завершения работ увеличится в 2 раза.

Подобный анализ очень важен при рассмотрении многопоточных алгоритмов. Очень
полезным при таком анализе является \textit{закон Амдала}, который гласит, что
\textit{увеличение производительности при распараллеливании ограничено объёмом
работ, выполняющихся последовательно}.

Пусть $S_n$ -- отношение времени выполнения работы одним процессором ко времени
выполнения этой же работы $n$ процессорами, $p$ - часть работы, которая может
быть выполнена параллельно. Тогда часть работы, которая должна выполняться
последовательно равна $1-p$. Примем за единицу время, необходимое одному
процессору, чтобы выполнить работу полностью. Тогда закон Амдала выражается
формулой

\begin{equation}
\label{amdal}
S_n = \frac{1}{1-p+\frac{p}{n}}
\end{equation}

Применим формулу \eqref{amdal} в примере с $5$ рабочими и $5$ комнатами, одна из
которых в двое больше остальных. Для этого предположим, что раскраска одним
рабочим одной маленькой комнаты требует $1$ единицу времени, раскраска большой
комнаты требует $2$ единицы времени. Тогда $5/6$ от всей работы могут быть
выполнены параллельно и $1/6$ должна выполняться последовательно, а на
выполнение всей работы требуется $6$ единиц времени. Применяя формулу Амдала
получаем

$$S_6 = \frac{1}{1/6 + 5/6*5}=\frac{1}{2/6}=3$$

Если всего одна комната в двое больше остальных, то вместо $5$-кратного
увеличения производительности получается только $3$-кратное!

Данный пример хорошо иллюстрирует, что даже небольшие последовательные части
алгоритма существенно сказываются на времени завершения всей задачи.

\subsection{Упражнения}

\begin{enumerate}

\item
Задача обедающих философов была впервые представлена Дейкстрой Э. В. -
пионером многопоточного программирования для того, чтобы осветить проблемы
взаимной блокировки и голодания. Предположим, есть 5 философов, вся жизнь
каждого из которых состоит лишь из приёма пищи и размышлений. Они сидят вокруг
круглого стола, на котором находится большая тарелка еды. Однако есть только 5
вилок, которые расположены вокруг этой тарелки. Каждый философ думает некоторое
время, затем пытается взять 2 ближайшие к нему вилки. Если ему это удаётся, он
ест некоторое время, затем кладёт вилки и думает опять. Так продолжается снова и
снова.

\begin{enumerate}
    \item Напишите программу, которая симулирует жизнь философов. Каждый философ
    представляется отдельным потоком, каждая вилка - разделяемый между потоками
    объект. При этом не должно быть ситуации когда вилкой владеют одновременно
    несколько философов.
    \item Убедитесь, что ваша программа никогда не попадёт в состояние взаимной
    блокировки потоков, когда каждый философ удерживает одну из вилок и ждёт,
    пока вторая освободится.
    \item Убедитесь, что ваша программа никогда не попадёт в состояние, когда
    один из философов голоден, но никак не может захватить обе вилки.
    \item Обобщите своё решение на случай $n$ философов так, чтобы она
    удовлетворяла двум предыдущим условиям.
\end{enumerate}

\item
В тюрьме сидят $N$ заключённых. Охранник решает провести испытание.
Перед началом испытания заключённые могут договориться о стратегии. Но, когда
испытание начнётся, заключённые будут изолированы друг от друга и никакая
коммуникация не будет возможна. Испытание заключается в следующем. Есть комната,
в которой есть лампочка, которую можно включить или выключить. Охранник
произвольно выбирает заключённого, который заходит в комнату и может включить
свет, выключить или оставить как есть, после чего он покидает комнату. Затем
выбирается следующий заключённый и т.д. Для любого $M > 0$ охранник гарантирует,
что каждый из заключённых побывает в комнате не менее $M$ раз.

Если один из заключённых, побывав в комнате в очередной раз, скажет:
"в этой комнате каждый заключённый побывал хотя бы раз" и это будет правда,
испытание заканчивается и охранник освобождает всех. Если ответ неверный,
все заключённые будут казнены.

\textit{a}) Придумать стратегию, которая позволит освободиться при условии что
заключённые знают, что изначально свет в комнате выключен.

\textit{b}) Придумать стратегию, которая позволит освободиться при условии что
заключённые не знают, включен или выключен свет в комнате изначально.

\item
В тюрьме сидят $N$ заключённых. Охранник решает провести испытание и дать шанс
заключённым обрести свободу. Перед началом испытания заключённые могут
договориться о стратегии. Но, когда испытание начнётся, заключённые не смогут
общаться между собой. Испытание заключается в следующем. Охранник выстраивает
заключённых один за одним и надевает на голову каждого шапку либо чёрного либо
белого цвета. Каждый заключённый видит шапки только тех, кто перед ним. Ни свою,
ни шапки предыдущих он не видит. Далее каждый заключённый, начиная с последнего,
называет цвет своей шапки, если он угадывает, он получает свободу. Придумайте
стратегию, которая позволит спастись как минимум $N-1$ заключённым.

\item
Используя закон Амдала, ответьте на следующие вопросы:
\begin{enumerate}
    \item Предположим, в программе есть функция, которая не может быть переделана
    для выполнения в многопоточном режиме, и она занимает $40\%$ всего времени
    выполнения программы. Какое максимальное увеличение производительности можно
    получить, запустив программу на компьютере с $n$ процессорами.
    \item Предположим, функция $M$ занимает $30\%$ времени выполнения программы.
    На сколько надо ускорить $M$, чтобы общее время выполнения программы
    увеличилось в $2$ раза.
    \item Предположим, функция $M$ может быть ускорена в 3 раза, сколько
    процентов от общего времени выполнения программы она должна занимать, чтобы
    общее время выполнения программы увеличилось в $2$ раза после ускорения $M$.
\end{enumerate}

\item
Запуск программы на $2$ процессорах приводит к увеличению производительности
$S_2$. Используя закон Амдала, выразите $S_n$ -- увеличение производительности
при запуске на $n$ процессорах через $S_2$.

\item
Предположим, для выполнения конкретной программы у Вас есть выбор: купить
компьютер с одним процессором, который может выполнять $n$ инструкций в секунду
или купить компьютер с $k$ процессорами, каждый из которых может выполнять $m$
инструкций в секунду. Используя закон Амдала обоснуйте свой выбор.

\end{enumerate}