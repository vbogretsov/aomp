\section{Взаимное исключение}

\subsection{Время}

Рассуждения о многопоточных вычислениях -- это, как правило, рассуждения о
времени. Поэтому, для дальнейшей работы необходимо формализовать несколько
понятий.

Здесь и далее будем считать, что время протекает одинаково для всех потоков.
Поток является конечным автоматом. Будем называть его состояния
\textit{событиями}. События будем считать \textit{мгновенными} -- различные
события происходят в различные моменты времени. Потоки обычно содержат циклы,
поэтому некоторые состояния потока $a_0,...,a_n$ будут повторяться в течение
работы программы. Обозначим через ${a_{i}}^{j}$ $j$-ое повторение события $a_i$.
Будем говорить, что событие $a$ \textit{предшествует} событию $b$ и писать
$a \rightarrow b$, если $a$ происходит в более ранний момент времени, чем $b$.
Отношение предшествования является полным порядком на множестве событий.

Пусть $a_0 \rightarrow a_1$, тогда \textit{интервал} $(a_0,a_1)$ -- это
промежуток времени между наступлениями событий $a$ и $b$. Говорят, что интервал
$I_A=(a_0,a_1)$ \textit{предшествует} интервалу $I_B=(b_0,b_1)$, если
$a_1 \rightarrow b_0$. Отношение предшествования является частичным порядком на
множестве интервалов. Два интервала, между которыми нет отношения
предшествования будем называть \textit{конкурентными}. По аналогии с событиями
будем обозначать $j$-ое выполнение интервала $I_A$ через ${I_A}^{j}$.
\textit{(Что означает $j$-ое выполнение интервала $I_A$?)}

\subsection{Критические секции}

Рассмотрим внимательнее проблему разделяемого между потоками счётчика из раздела
$\ref{1-1}$. Ниже приведена реализация для однопоточного решения.

\begin{lstlisting}[caption={}\label{counter-single-thread}]
void counter_increment(size_t* counter)
{
    counter = counter + 1;
}
\end{lstlisting}

Однако, данное решение не подходит для случая, когда переменная $counter$
изменяется одновременно из нескольких потоков. Проблема заключается в том, что
для изменения переменной $counter$ каждый поток должен сперва прочитать её
значение, потом увеличить прочитанное значение на $1$ и записать результат
обратно в $counter$. Предположим, поток $A$ читает значение $counter$, равное
$1$. После этого планировщик операционной системы приостанавливает данный поток
и переключается на поток $B$, который также также пытается изменить $counter$,
для чего сперва считывает её значение, равное $1$, увеличивает его и записывает
обратно в $counter$, после чего планировщик приостанавливает поток $B$ и вновь
переключается на поток $A$, который увеличивает недавно прочитанное значение на
$1$ и записывает его обратно в $counter$. В результате $counter$ будет содержать
значение $2$, вместо правильного значения $3$.

Данную проблему можно решить если код строки $3$ будет выполняться внутри
\textit{критической секции}.

\begin{definition}. Критической секцией называется участок кода,
который в данный момент времени может выполняться только одним потоком.
\end{definition}

Критическая секция позволяет обеспечивать свойство взаимного исключения.
Большинство современных операционных систем предоставляют инструмент для
создания критических секций под названием \textit{мьютекс}.

В библиотеке \textit{pthread} мьютекс представляется объектом с типом данных
\textit{pthread\_mutex\_t}. Для входа в критическую секцию используется функция
\textit{pthread\_mutex\_lock}, для выхода из критической секции --
\textit{pthread\_mutex\_unlock}. Пример кода, приведённого ниже показывает как
с помощью критической секции можно решить проблему разделяемого между потоками
счётчика.

\begin{lstlisting}[caption={}\label{counter-multy-thread}]
typedef struct
{
    pthread_mutex_t lock;
    size_t value;
} counter_t;

void counter_increment(counter_t* counter)
{
    pthread_mutex_lock(&counter->lock);    // enter critical section
    counter->value = counter->value + 1;   // inside critical section
    pthread_mutex_unlock(&counter->lock);  // leave critical section
}
\end{lstlisting}

Формализуем свойства, которыми должен обладать алгоритм, использующий
критические секции. Пусть $CS^j_A$ -- интервал, в течение которого поток $A$
выполняет код внутри критической секции $j$-ый раз. Также будем считать, что
каждый поток бесконечно часто выполняет некоторый код внутри критической секции.

\textbf{Взаимное исключение}. Для любых двух потоков $A$, $B$ и натуральных $i$,
$j$ выполняется либо $CS^j_A \rightarrow CS^k_B$ либо
$CS^k_B \rightarrow CS^j_A$.

\textbf{Отсутствие взаимоблокировок}. Если несколько потоков пытаются войти в
одну и ту же критическую секцию, то один из них сможет это сделать.

\textbf{Отсутствие голодания}. Если поток пытается войти в критическую секцию
несколько раз, то существует $k \in \mathbb{N}$ такое, что $k$-ая попытка
завершится успешно.

\begin{note}.Отсутствие голодания влечёт отсутствие взаимоблокировок.
\end{note}

Взаимное исключение обеспечивает корректность результата программы. Отсутствие
взаимоблокировок гарантирует, что программа завершится. Важно отметить, что
отсутствие взаимоблокировок в реализации критической секции не гарантирует
отсутствие взаимоблокировок в процессе работы программы. Рассмотрим пример,
когда поток $A$ вошёл в критическую секцию $S_1$. В этот же момент поток $B$
вошёл в критическую секцию $S_2$. Теперь поток $A$ пытается войти в критическую
секцию $S_2$, а поток $B$ в критическую секцию $S_1$. Поток $A$ не выйдет из
$S_1$, пока не войдёт в $S_2$. Поток $B$ не выйдет из $S_2$, пока не войдёт в
$S_1$. Таким образом $A$ никогда не войдёт в $S_2$, а $B$ никогда не войдёт в
$S_1$.

\subsection{Алгоритм Петерсона}

\subsection{Блокировка с фильтрацией}

\subsection{Справедливость блокировки}

\subsection{Алгоритм Лэмпорта-Бекери}

\subsection{Связанные временные метки}

\subsection{Нижняя граница числа позиций}

\subsection{Заключение}

\subsection{Упражнения}